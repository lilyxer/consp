- Класс — это шаблон кода, по которому создаются объекты. 
- Объект — это программная сущность, обладающая определённым состоянием (атрибуты) и поведением (методы). Объект также можно считать конкретным представителем класса.

#### Принципы ООП
- Абстракция — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором атрибутов и методов и при этом с достаточной точностью для решаемой задачи.
- Инкапсуляция имеет два основных смысла. С одной стороны, она объединяет атрибуты и методы в одном объекте. С другой стороны, инкапсуляция обозначает сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта, так как это может быть небезопасно.
- Наследование — способ создания класса на основе уже существующего, при котором дочерний класс заимствует атрибуты и методы родительского класса, а также добавляет собственные.
- Полиморфизм – это множество форм. Однако в понятиях ООП имеется в виду, скорее, обратное. Объекты разных классов, с разной внутренней реализацией, могут иметь одинаковые интерфейсы. 

#### Атрибуты объектов и классов
```
    dir()                           # получение списка всех атрибутов и методов объекта
    __dict__                        # возвращает словарь с атрибутами объекта
    getattr(obj, name, default)     # возвращает значение атрибута name объекта obj
    setattr(obj, name, value)       # уcтанавливает значение атрибута name объекта obj равное value
    delattr(obj, name)              #  удаляет атрибут name у объекта obj !! AttributeError !!
    hasattr(obj, name)              # возвращает истину/ложь есть ли атрибут у объекта
    callable(class)                 # является ли объект вызываемым
```

#### Модификаторы доступа
```python
    self.name  # public
    self._name  # protected 
    self.__name  # private 

class Cat:
    def __init__(self, name):                           # инициализируем экземпляр
        self._name = name                               # защищаем атрибут
    def get_name(self):                                 # создаем геттер,
        return self._name                               # геттер возращает защищиенный атрибут
    def set_name(self, name):                           # создаем сеттер
        if isinstance(name, str) and name.isalpha():    # проверка
            self._name = name                           # устанавливаем новое значение защищенном атрибуту
        else:
            raise ValueError('Некорректное имя')
    def del_name(self, name):                           # создаём делитер
        del self._name                                  # удаляем имя
    name = property(fget=get_name, fset=set_name,       # если реализована функция property можно напрямую обпащаться к методам доступа
                    fdel=del_name, fdoc)                # по имени атрибута
```

#### Декораторы
```python
-   @property                                           # модификаторы доступа можно называть как и атрибут применив к ним декоратор
    def name(self) -> str: return self._name

-   @classmethod                                        # метод класса менять состояние конкретного объекта не может, доступ лишь к классу
    def method(cls, *args) -> object:                   # зачастую используют для создания нового экземпляра
        return cls(*args)                               # например dict.fromkeys

-   @staticmethod                                       # статические методы не могут изменять ни состояние объекта, ни состояние класса
    def method(*args) -> any:                           # обычно это вспомогательная функция, напрмер проверки валидности или расчётов
        print(*args)
        
-   @singledispatchmethod                               # from functools import singledispatchmethod, декортаор создан для перегрузки методов
    def some_method(self, arg):                         # метод будет срабатывать в зависимости от того какой тип у первого аргумента 
        print('базовая реализация либо raise ошибку')   # после self
    @some_method.register(int)                          # и если такой метод прописан будет производиться действие
    def from_int(self, arg:int):                        # иначе - базовая реализация
        print('реализация где арг - число!')
```

#### __dunders__
- __создание, инициализация и очищение объектов__
```python 
    def __init__(self, name: str, age: int) -> None:    # инициализация экземпляра объекта
        self.name, self.age = name, age

    def __new__(cls, *args, **kwargs) -> object:        # создание файла, возвращает экземпляр класса
        return object.__new__(cls)                      # <==> super().__new__(cls)     staticmethod!

    def __del__(self) -> None:                          # финализатор объекта
        ...
```

- __строковое представление__
```python
    def __str__(self) -> str:                           # неформально отображение объекта
        return '...'                                    # возврат только строки!
    
    def __repr__(self) -> str:                          # формальное отображение объекта
        return f'{self.class.__name__}(\'{self.args}\')'# должен возвращать строку, которую можно преобразовать обратно в объект с помощью функции eval().
```

- __сравнение объектов__
```python
    #Hash-Equal контракт    необходимо переопредять вместе с __hash__
    def __eq__(self, other) -> bool:                    # проверка на равенство
        if isinstance(other, self(type)):               # проверяем на соответсвтие классов
            return self.x == other.x
        return NotImplemented                           # принято возвращать константу если объекты имеют разные классы
    
    __ne__()                                            # проверка на НЕРАВЕНСТВО, можно не писать если есть __eq__
    __lt__()                                            # проверка на МЕНЬШЕ, можно не писать если есть __gt__
    __gt__()                                            # проверка на БОЛЬШЕ, можно не писать если есть __lt__
    __le__()                                            # проверка на МЕНЬШЕилиРАВНО, можно не писать если есть __ge__
    __ge__()                                            # проверка на БОЛЬШЕилиРАВНО, можно не писать если есть __le__
    
    @total_ordering                           
    class <SomeClass>:                                  # достаточно объявить лишь __eq__ и любой другой метод сравнения
        def __eq__(self, other):...
        def __lt__(self, other):...
```

- __унарные операторы__
```python
    __pos__()                                           # унарный плюс
    __neg__()                                           # унарный минус
    __invert__()                                        # инвертирование, только для int/bool !!! -(x + 1) !!!
    __abs__()                                           # определяет поведение для встроенной функции abs()
    __round__()                                         # определяет поведение для встроенной функции round(<some>: n)
    __trunc__(), __floor__(), __ceil__()                # методы модуля math
```

- __арифметические операции__
```python
    __add__(), __sub__(), __mul__(), __truediv__(), __floordiv__(), __mod__()       # соот-но +, -, *, /, //, %
    x.__add__(y) => y.__radd__(x)                       # если метод add у первого объекта не определен или возвращена 
    __radd__ = __add__, __rmul__ = __mul__              # константа NotImplemented вызывается radd у другого!
    __pow__()                                           # **
    __divmod__()                                        # divmod()
    __lshift__()                                        # определяет поведение для двоичного сдвига влево (оператор <<)
    __rshift__()                                        # определяет поведение для двоичного сдвига вправо (оператор >>)
    __and__()                                           # определяет поведение для двоичного И (оператор &)
    __or__()                                            # определяет поведение для двоичного ИЛИ (оператор |)
    __xor__()                                           # определяет поведение для двоичного XOR, (оператор ^)
    # i в названиях методов составного присваивания является сокращением слова inplace (на месте). !!!Возвращают себя!!!
    __iadd__(), __isub__(), __imul__(), __itruediv__(), __ifloordiv__(), __imod__() # соот-но +=, -=, *=, /=, //=, %=
```

-__вызываемые объекты__
```python
    class Cat:
        def __init__(self, name) -> None:
            self.name=name
        def __call__(self, speech: str) -> str:         # метод позволяет экземплярам класса вести себя так, как будто они функции, необходим для декорирования
            return f'{self.name} говорит {speech}'      # т.е. мы можем вызывать их, передавать их в функции, 
    cat = Cat('Alice')                                  # которые ожидают в качестве аргумента функцию,
    print(cat('Give me a some food!!'))                 # см. реализации
```

- __преобразование типов__
```python
    def __bool__(self) -> bool:                         # определив метод мы определяем какие экземпляры считаем истинными, а какие ложными
                                                        # !!! bool необходима при проверке на истинность при помощи усл.оператора if, all(), any() !!!
    __int__(), __float__(), __complex__()               # определет поведение функций, возвращает значение соот-ее преобразованному типу
```

-__работа с атрибутами объектов__
```python
    __getattribute__()                                  # вызывается при обращении к любому атрибуту
    __getattr__()                                       # вызывается при обращении к несуществующему атрибуту
    __setattr__()                                       # вызывается при установке атрибута или изменении его значения
    __delattr__()                                       # вызывается при удалении любого атрибута
```

- __хэширование объекта__
```python
    hash(obj) == id(obj) // 16                          # хэши одинаковых объектов равны    Hash-Equal контракт
    __hash__(self)                                      # необходимо переопредять вместе с __eq__, если класс неизменяем
    __hash__ = None                                     # не хэшируемый класс
```

- __Итерируемые объекты и итераторы__
```python
    def __iter__(self) -> Iterator: ...                 # все итерируемые объекты должны иметь данный метод
    def __next__(self) -> object: ...                   # все итераторы имеют этот метод
```

- __последовательности__
```python
    def __len__(self) -> int: ...                       # len()
    def __getitem__(self, key) -> object: ...           # self[key]
    def __setitem__(self, key, value) -> None: ...      # self[key] = value
    def __delitem__(self, key) -> None: ...             # del
    def __contains__(self, item) -> bool: ...           # item (in / not in) self
    slice(10) == [:10] == slice(None, 10, None)         # срез возвращает новый экземпляр этого же объекта
    indices(x: int)                                     # возвращает заполненный срез в зависимотси от переданной длинны
    def __reversed__(self) -> Iterator: ...             # reversed()
```

- __оператор with__
```python
    file.closed -> bool                                 # проверка закрыт ли файл
    open(file, <режим>, encoding='')                    # возвращает специальный файловый объект (тип TextIOWrapper)
    file.readable() -> bool                             # можно ли читать файл  
    file.writable() -> bool                             # можно ли писать в файл
    __enter__(self)                                     # вводит контекст и может вернуть объект
    __exit__(self, exc_type, exc_value, traceback)      # тип исключения, объект исключения, информация о трассировке, если хотим подавить ошибку: if isinstance(exc_value, IndexError): return True
```

- __класс данных__
```python
    def __post_init__(self)                             # автоматически вызывается после метода __init__(), можно работать с атрибутами
```